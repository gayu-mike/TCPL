.. _pointer-and-array:

=========
指针与数组
=========

指针是保存变量地址的变量.

---------
指针与地址
---------

程序的变量是存储在连续的存储单元中的(虚拟地址), 比如: char 1 bytes, short 2 bytes,
long 4 bytes.  指针也是变量, 它一般是 2 | 4 bytes.

.. code-block:: c

    int x = 1, y = 2, z[10];
    int *ip;    // 声明指针 ip, *ip 的返回值是 int
    ip = &x;    // &x 对 x 取地址
    y = *ip;    // 指针 ip 取值 *ip
    *ip = 0;    // x == 0
    ip = &z[0]; // &z[0] 数组的第一个元素取地址

每个指针都必须指定一种类型, 该类型可以出现的任何上下文都可以出现该指针:

.. code-block:: c

    *ip = *ip + 10;
    y = *ip + 1;
    *ip += 1;
    ++*ip;
    (*ip)++;    // 从右到左计算, 所以要加括号

------------
指针与函数参数
------------

*指针参数使被调函数能修改主调函数中对象的值.*

下面来说明这一点, 假设有如下情况 --
我们要实现一个函数 ``swap(a, b)``, 把 a, b 的值调换:

.. code-block:: c

    void swap(int a, int b)
    {
        int tmp;
        tmp = a;
        a = b;
        b = tmp;
    }

这是之前程序写过也很直接的想法. 但是 C 是通过 copy 的方式传参的, 也就是说以上如果:

.. code-block:: c

    int x = 1, y = 2;
    swap(x, y);

会产生 a = x, b = y; 不影响 x, y 的值.
那么如果要达到原来的目的, 我们使用指针作为行参定义 swap:

.. code-block:: c

    void swap(int *a, int *b)
    {
        int tmp;
        tmp = *a;
        *a = *b;
        *b = tmp;
    }

再通过传入地址实参调用:

.. code-block:: c

    swap(&x, &y);
    // a = &x, b = &y;

就可以影响到实参本身.